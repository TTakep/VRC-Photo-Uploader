<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRC Photo Uploader for Discord</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        /* --- Theme Colors --- */
        :root {
            --bg-primary: #2c2f33;   /* メイン背景 */
            --bg-secondary: #23272a; /* カード背景 */
            --text-primary: #ffffff; /* メイン文字 */
            --text-muted: #b9bbbe;   /* 補足文字（明るく修正） */
            --accent: #7289da;       /* アクセントカラー */
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Bootstrapのtext-mutedをオーバーライドして見やすくする */
        .text-muted {
            color: var(--text-muted) !important;
        }

        .container {
            max-width: 800px;
            margin-top: 50px;
        }

        .card {
            background-color: var(--bg-secondary);
            border: none;
            color: var(--text-primary);
        }

        .form-control {
            background-color: var(--bg-primary);
            border: 1px solid var(--bg-secondary);
            color: var(--text-primary);
        }
        .form-control:focus {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            border-color: var(--accent);
            box-shadow: none;
        }
        /* input type=numberの右側のスピンボタンを消す（デザイン調整） */
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }

        .drop-zone {
            border: 3px dashed var(--accent);
            border-radius: 10px;
            padding: 50px;
            text-align: center;
            background-color: var(--bg-secondary);
            transition: all 0.2s ease;
            cursor: pointer;
        }
        .drop-zone:hover, .drop-zone.dragover {
            background-color: var(--accent);
            border-color: var(--text-primary);
            color: var(--text-primary);
        }
        .drop-zone p {
            font-size: 1.2rem;
            color: var(--text-muted); /* 明るく修正 */
            pointer-events: none;
            margin-bottom: 0;
        }
        .drop-zone:hover p {
            color: var(--text-primary);
        }

        #logArea {
            max-height: 300px;
            overflow-y: auto;
            background-color: #000000;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            color: #dbdee1; /* デフォルト文字色を明るく */
        }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: var(--bg-primary); }
        ::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: #5b6eae; }
    </style>
</head>
<body>

<div class="container mb-5">
    <h2 class="text-center mb-4 fw-bold"><i class="bi bi-discord"></i> VRC Photo Uploader</h2>
    
    <div class="card mb-4 shadow">
        <div class="card-body p-4">
            <h5 class="card-title mb-3 fw-bold">設定</h5>
            <div class="mb-4">
                <label for="webhookUrl" class="form-label fw-bold">Discord Webhook URL</label>
                <input type="password" class="form-control form-control-lg" id="webhookUrl" placeholder="https://discord.com/api/webhooks/...">
                <div class="form-text text-muted mt-2">
                    <small>※ URLはブラウザ内に暗号化されずに保存されます。共有PCでは使用しないでください。外部サーバーへは送信されません。</small>
                </div>
            </div>
            <div class="row">
                 <div class="col-md-6 mb-3">
                    <label for="maxFileSize" class="form-label fw-bold">最大ファイルサイズ (MB)</label>
                    <div class="input-group">
                        <input type="number" class="form-control form-control-lg" id="maxFileSize" value="8" min="1">
                        <span class="input-group-text bg-secondary text-light border-secondary">MB</span>
                    </div>
                    <div class="form-text text-muted mt-2">
                        <small>これを超えると、PNG形式を維持したまま自動的に解像度を縮小します。</small>
                    </div>
                 </div>
            </div>
        </div>
    </div>

    <div id="dropZone" class="drop-zone mb-4 shadow-sm">
        <p>ここに写真をドラッグ＆ドロップ<br>またはクリックしてファイルを選択</p>
        <input type="file" id="fileInput" multiple accept="image/png, image/jpeg, image/webp" style="display: none;">
    </div>

    <div class="card shadow">
        <div class="card-header d-flex justify-content-between align-items-center py-3 bg-secondary text-light border-bottom-0">
            <span class="fw-bold">処理ログ</span>
            <button id="clearLog" class="btn btn-sm btn-outline-light">ログ消去</button>
        </div>
        <div class="card-body p-0">
            <div class="progress" style="height: 5px; border-radius: 0;">
                <div id="progressBar" class="progress-bar bg-success" role="progressbar" style="width: 0%; transition: width 0.3s ease;"></div>
            </div>
            <div id="logArea" class="p-3"></div>
        </div>
    </div>
</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">

<script>
    // --- Configuration & State ---
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const webhookInput = document.getElementById('webhookUrl');
    const maxSizeInput = document.getElementById('maxFileSize');
    const logArea = document.getElementById('logArea');
    const progressBar = document.getElementById('progressBar');
    
    let uploadQueue = [];
    let totalFilesToProcess = 0;
    let processedFilesCount = 0;
    let isProcessing = false;

    // --- Initialization ---
    window.addEventListener('load', () => {
        const savedUrl = localStorage.getItem('vrc_discord_webhook');
        if (savedUrl) webhookInput.value = savedUrl;
        const savedSize = localStorage.getItem('vrc_max_file_size');
        if (savedSize) maxSizeInput.value = savedSize;
    });

    webhookInput.addEventListener('change', () => {
        localStorage.setItem('vrc_discord_webhook', webhookInput.value.trim());
    });
    maxSizeInput.addEventListener('change', () => {
        localStorage.setItem('vrc_max_file_size', maxSizeInput.value);
    });

    // --- Drag & Drop Handlers ---
    dropZone.addEventListener('click', () => fileInput.click());
    
    fileInput.addEventListener('change', (e) => {
        handleFiles(e.target.files);
        fileInput.value = ''; 
    });

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropZone.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }

    ['dragenter', 'dragover'].forEach(eventName => {
        dropZone.addEventListener(eventName, () => dropZone.classList.add('dragover'), false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
        dropZone.addEventListener(eventName, () => dropZone.classList.remove('dragover'), false);
    });

    dropZone.addEventListener('drop', (e) => {
        const dt = e.dataTransfer;
        handleFiles(dt.files);
    });

    // --- Main Logic ---

    function handleFiles(files) {
        if (!webhookInput.value) {
            alert('先にWebhook URLを設定してください。');
            return;
        }

        // Filter only images
        const fileArray = Array.from(files).filter(file => file.type.startsWith('image/'));
        const total = fileArray.length;
        
        if (total === 0) {
            addLog('画像ファイルが選択されていません。', '#ff5555');
            return;
        }

        addLog(`--- ${total}枚の画像を受け付けました ---`, '#7289da');

        // Add to queue
        fileArray.forEach(file => {
            uploadQueue.push(file);
        });
        totalFilesToProcess += total;

        if (!isProcessing) {
            processQueue();
        }
    }

    async function processQueue() {
        if (uploadQueue.length === 0) {
            isProcessing = false;
            totalFilesToProcess = 0;
            processedFilesCount = 0;
            updateProgress(0);
            addLog('すべての処理が完了しました。', '#4caf50');
            return;
        }

        isProcessing = true;
        const file = uploadQueue.shift();
        
        try {
            await processAndUpload(file);
        } catch (error) {
            addLog(`エラー: ${file.name} - ${error.message}`, '#ff5555');
        } finally {
            processedFilesCount++;
            updateProgress((processedFilesCount / totalFilesToProcess) * 100);
        }

        // Discord Rate Limit Avoidance: Wait 1 second base time
        await new Promise(r => setTimeout(r, 1000));
        
        // Recursion
        processQueue();
    }

    async function processAndUpload(file) {
        const maxBytes = maxSizeInput.value * 1024 * 1024;
        let fileToSend = file;
        const originalSizeMB = (file.size / 1024 / 1024).toFixed(2);

        addLog(`処理開始: ${file.name} (${originalSizeMB} MB)`, '#dbdee1');

        // Check if resize is needed
        if (file.size > maxBytes) {
            addLog(`サイズ超過 (${maxSizeInput.value}MB超): リサイズを開始します...`, '#ffa500');
            try {
                fileToSend = await resizeImageToFit(file, maxBytes);
                const newSizeMB = (fileToSend.size / 1024 / 1024).toFixed(2);
                addLog(`リサイズ完了: ${newSizeMB} MB に縮小しました`, '#ffa500');
            } catch (e) {
                throw new Error('リサイズ処理に失敗しました: ' + e);
            }
        }

        await uploadToDiscord(fileToSend, file.name);
    }

    // Resize Logic (Iterative downscaling to keep PNG format)
    function resizeImageToFit(file, maxBytes) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = async () => {
                let canvas = document.createElement('canvas');
                let ctx = canvas.getContext('2d');
                
                let width = img.width;
                let height = img.height;
                // Start with a more aggressive step down for very large files
                let scale = (file.size > maxBytes * 2) ? 0.75 : 0.9; 
                let blob = null;
                let attempts = 0;

                addLog(`元の解像度: ${width}x${height}`, '#888');

                do {
                    if (attempts > 0) {
                        width = Math.floor(width * scale);
                        height = Math.floor(height * scale);
                        // If still too big after many attempts, scale more aggressively
                        if (attempts > 5) scale = 0.8;
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    // Better quality scaling
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    ctx.drawImage(img, 0, 0, width, height);

                    // Use original mime type if it is PNG, otherwise default to PNG for lossless
                    const mimeType = file.type === 'image/png' ? 'image/png' : 'image/png';
                    blob = await new Promise(r => canvas.toBlob(r, mimeType));
                    attempts++;
                    
                    // Failsafe
                    if (attempts > 20 || width < 100 || height < 100) {
                         break;
                    }
                    
                    if (blob.size > maxBytes) {
                         addLog(`...試行${attempts}: ${width}x${height} -> ${(blob.size/1024/1024).toFixed(2)}MB (まだ大きすぎます)`, '#888');
                    }

                } while (blob.size > maxBytes);

                if (blob.size > maxBytes) {
                    reject('解像度を下げても目標サイズに収まりませんでした。');
                } else {
                    addLog(`最終解像度: ${width}x${height}`, '#888');
                    // Recreate File object to preserve original name
                    const newFile = new File([blob], file.name, { type: blob.type });
                    resolve(newFile);
                }
                // Clean up memory
                canvas = null;
                ctx = null;
            };
            img.onerror = () => reject('画像の読み込みに失敗しました。破損している可能性があります。');
            
            // Clean up object URL
            const objectUrl = URL.createObjectURL(file);
            img.src = objectUrl;
            img.onloadend = () => URL.revokeObjectURL(objectUrl);
        });
    }

    // Discord Webhook Upload with Retry Logic
    function uploadToDiscord(file, originalName, retryCount = 0) {
        return new Promise((resolve, reject) => {
            if (retryCount > 5) {
                reject('リトライ回数が上限に達しました。送信を諦めます。');
                return;
            }

            addLog(`${originalName} を送信中...`, '#dbdee1');
            const formData = new FormData();
            formData.append('file', file, originalName);

            const xhr = new XMLHttpRequest();
            xhr.open('POST', webhookInput.value.trim());

            xhr.onload = function () {
                if (xhr.status >= 200 && xhr.status < 300) {
                    addLog(`送信成功: ${originalName} ✅`, '#4caf50');
                    resolve();
                } else if (xhr.status === 429) {
                    // Rate Limited
                    let retryAfter = 5; // Default 5s
                    try {
                        const response = JSON.parse(xhr.responseText);
                        retryAfter = response.retry_after || retryAfter;
                        // Discord uses milliseconds sometimes, but usually seconds for retry_after in JSON. 
                        // Safety check: if it seems too small, assume it's seconds.
                        if (retryAfter < 100) retryAfter = retryAfter; 
                        else retryAfter = retryAfter / 1000;

                    } catch (e) { /* ignore JSON parse error */ }

                    const waitMs = (retryAfter * 1000) + 500; // Add buffer
                    addLog(`レートリミット到達 (429)。${retryAfter.toFixed(1)}秒待機して再送します... (試行: ${retryCount+1})`, '#ffa500');
                    
                    setTimeout(() => {
                        uploadToDiscord(file, originalName, retryCount + 1).then(resolve).catch(reject);
                    }, waitMs);

                } else {
                    addLog(`送信失敗: Status ${xhr.status} - ${xhr.statusText}`, '#ff5555');
                    reject(`HTTP Status ${xhr.status}`);
                }
            };

            xhr.onerror = () => {
                addLog('ネットワークエラーが発生しました。', '#ff5555');
                reject('Network Error');
            };
            
            xhr.send(formData);
        });
    }

    // --- UI Helpers ---
    function addLog(text, color) {
        const div = document.createElement('div');
        const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        div.innerHTML = `<span style="color:#888; font-size:0.8em;">[${time}]</span> ${text}`;
        div.style.color = color || '#dbdee1'; // デフォルト文字色を明るく
        logArea.appendChild(div);
        // Smooth scroll to bottom
        logArea.scrollTo({ top: logArea.scrollHeight, behavior: 'smooth' });
    }

    function updateProgress(percent) {
        progressBar.style.width = percent + '%';
    }
    
    document.getElementById('clearLog').addEventListener('click', () => {
        logArea.innerHTML = '';
        updateProgress(0);
    });
</script>

</body>
</html>
